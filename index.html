<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>50MB Video Recorder / Converter (MP4-first)</title>
  <style>
    :root{
      --bg:#0b0f14;
      --card:#111826;
      --muted:#90a4b8;
      --text:#e8f0ff;
      --accent:#4da3ff;
      --danger:#ff4d4d;
      --ok:#46d38a;
      --border:rgba(255,255,255,.10);
      --shadow: 0 10px 30px rgba(0,0,0,.25);
      --radius:16px;
      --pad:14px;
      color-scheme: dark;
    }
    [data-theme="light"]{
      --bg:#f6f7fb;
      --card:#ffffff;
      --muted:#5a6b7c;
      --text:#0b1522;
      --accent:#2563eb;
      --danger:#dc2626;
      --ok:#16a34a;
      --border:rgba(0,0,0,.10);
      --shadow: 0 10px 30px rgba(0,0,0,.08);
      color-scheme: light;
    }

    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0;
      background:var(--bg);
      color:var(--text);
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      overflow-x:hidden;
    }

    header{
      position:sticky; top:0; z-index:5;
      padding: calc(env(safe-area-inset-top) + 10px) 12px 10px;
      background: linear-gradient(to bottom, rgba(0,0,0,.35), transparent);
      backdrop-filter: blur(8px);
    }
    .row{display:flex; gap:10px; align-items:center; justify-content:space-between; flex-wrap:wrap}
    h1{font-size:16px; margin:0; letter-spacing:.2px}

    main{
      padding:12px;
      padding-bottom: calc(env(safe-area-inset-bottom) + 14px);
      max-width: 980px;
      margin: 0 auto;
    }

    .card{
      background:var(--card);
      border:1px solid var(--border);
      border-radius:var(--radius);
      box-shadow:var(--shadow);
      overflow:hidden;
    }
    .card h2{
      margin:0;
      font-size:14px;
      padding:12px var(--pad);
      border-bottom:1px solid var(--border);
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
    }
    .card .content{padding: var(--pad)}

    .btn{
      appearance:none;
      border:1px solid var(--border);
      background:transparent;
      color:var(--text);
      padding:10px 12px;
      border-radius:12px;
      cursor:pointer;
      display:inline-flex;
      align-items:center;
      justify-content:center;
      gap:8px;
      touch-action: manipulation;
      -webkit-tap-highlight-color: transparent;
      user-select:none;
      min-height: 44px;
    }
    .btn.primary{background:var(--accent); border-color:transparent; color:white}
    .btn.danger{background:var(--danger); border-color:transparent; color:white}
    .btn:disabled{opacity:.45; cursor:not-allowed}

    .tabs{
      display:flex;
      gap:10px;
      padding: 10px var(--pad);
      border-bottom:1px solid var(--border);
      overflow-x:auto;
      -webkit-overflow-scrolling: touch;
    }
    .tab{
      flex:0 0 auto;
      padding:10px 12px;
      border-radius:999px;
      border:1px solid var(--border);
      color:var(--muted);
      cursor:pointer;
      background:transparent;
      min-height: 44px;
    }
    .tab.active{
      background:rgba(77,163,255,.18);
      color:var(--text);
      border-color:rgba(77,163,255,.45);
    }

    video{
      width:100%;
      border-radius:14px;
      background:#000;
      max-height: 60vh;
    }

    .status{
      display:flex;
      flex-wrap:wrap;
      gap:8px;
      margin-top:10px;
    }
    .pill{
      display:inline-flex;
      align-items:center;
      gap:8px;
      padding:8px 10px;
      border:1px solid var(--border);
      border-radius:999px;
      color:var(--muted);
      font-size:12px;
      min-width: 0;
    }
    .mono{font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace}
    .note{font-size:12px; color:var(--muted); line-height:1.35; margin-top:10px}
    .ok{color:var(--ok)}
    .warn{color:var(--danger)}

    .bar{
      height:10px;
      background: rgba(255,255,255,.08);
      border-radius:999px;
      overflow:hidden;
      border:1px solid var(--border);
      margin-top:10px;
    }
    .bar > div{height:100%; width:0%; background: var(--accent);}

    .actions{
      display:flex;
      gap:10px;
      flex-wrap:wrap;
      margin-top:12px;
    }

    /* Settings drawer */
    .sheetOverlay{
      position:fixed; inset:0;
      background: rgba(0,0,0,.55);
      display:none;
      z-index:50;
    }
    .sheet{
      position:fixed;
      left:0; right:0;
      bottom:0;
      transform: translateY(110%);
      transition: transform .2s ease;
      z-index:60;
      background: var(--card);
      border-top-left-radius: 20px;
      border-top-right-radius: 20px;
      border:1px solid var(--border);
      box-shadow: var(--shadow);
      max-height: 82vh;
      overflow:auto;
      -webkit-overflow-scrolling: touch;
      padding-bottom: calc(env(safe-area-inset-bottom) + 10px);
    }
    .sheetHeader{
      padding: 12px var(--pad);
      border-bottom:1px solid var(--border);
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      position:sticky;
      top:0;
      background: var(--card);
      z-index: 2;
    }
    .sheetHeader h3{margin:0; font-size:14px;}
    .sheetBody{padding: var(--pad); display:grid; gap:12px;}

    label{display:block; font-size:12px; color:var(--muted); margin-bottom:6px}
    select,input[type="range"],input[type="file"]{
      width:100%;
      padding:10px 12px;
      border-radius:12px;
      border:1px solid var(--border);
      background: transparent;
      color:var(--text);
      outline:none;
      min-height: 44px;
    }
    input[type="range"]{padding: 10px 0; min-height:auto}

    .twoCol{
      display:grid;
      gap:12px;
      grid-template-columns: 1fr 1fr;
    }
    @media (max-width: 420px){
      .twoCol{grid-template-columns: 1fr}
    }

    .progressBox{
      display:none;
      margin-top:10px;
      border:1px solid var(--border);
      border-radius:12px;
      padding:10px 12px;
    }
    .progressTop{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      flex-wrap:wrap;
    }
    .log{
      margin-top:8px;
      font-size:12px;
      color:var(--muted);
      white-space:pre-wrap;
      max-height: 160px;
      overflow:auto;
      border-top: 1px solid var(--border);
      padding-top: 8px;
    }

    .hiddenTools{
      position:absolute;
      left:-9999px;
      top:-9999px;
      width: 1px;
      height: 1px;
      overflow:hidden;
    }

    .banner{
      border:1px solid var(--border);
      border-radius: 14px;
      padding: 12px;
      background: rgba(255,255,255,.04);
      margin-bottom: 12px;
    }
    .bannerTitle{font-weight:700; font-size:13px; margin-bottom:6px;}
    .banner p{margin:0; font-size:12px; color:var(--muted); line-height:1.35;}
  </style>
</head>
<body>
  <header>
    <div class="row">
      <h1>50MB Video Recorder / Converter (MP4-first)</h1>
      <div class="row" style="gap:8px">
        <button id="settingsBtn" class="btn" type="button">‚öôÔ∏è Settings</button>
        <button id="themeBtn" class="btn" type="button">üåì Theme</button>
      </div>
    </div>
  </header>

  <main>
    <section class="card">
      <h2>
        <span>Mode</span>
        <span class="pill">Limit: <span class="mono" id="limitLabel">50.0 MB</span></span>
      </h2>

      <div class="content">
        <div id="secureBanner" class="banner" style="display:none">
          <div class="bannerTitle warn">iPhone camera needs HTTPS</div>
          <p>
            If you opened this from <span class="mono">Files</span> (file://), iPhone will usually block the camera.
            Host this page on HTTPS (Netlify/GitHub Pages) and open it in Safari.
          </p>
        </div>

        <div id="formatBanner" class="banner" style="display:none">
          <div class="bannerTitle warn">MP4 encoding not supported here</div>
          <p>
            This browser/device can‚Äôt encode MP4 using MediaRecorder, so output will be WebM (not accepted by GorillaDesk).
            Workaround: run this page in iPhone Safari (HTTPS) or use a server-side converter.
          </p>
        </div>

        <div class="tabs" role="tablist" aria-label="mode tabs">
          <button id="tabRecord" class="tab active" type="button" role="tab" aria-selected="true">üé• Record</button>
          <button id="tabUpload" class="tab" type="button" role="tab" aria-selected="false">üìÅ Upload</button>
        </div>

        <div id="recordPanel" style="margin-top:12px">
          <video id="preview" playsinline autoplay muted></video>

          <div class="actions">
            <button id="enableCameraBtn" class="btn primary" type="button">üì∑ Enable Camera</button>
            <button id="restartPreviewBtn" class="btn" type="button" disabled>üîÑ Restart Preview</button>
          </div>

          <div class="status" aria-live="polite">
            <span class="pill">Recorded: <span class="mono" id="recSizeLabel">0.0 MB</span></span>
            <span class="pill">Time: <span class="mono" id="recTimeLabel">0s</span></span>
            <span class="pill">Torch: <span class="mono" id="torchLabel">n/a</span></span>
            <span class="pill">Zoom: <span class="mono" id="zoomLabel">n/a</span></span>
          </div>

          <div class="bar" title="Recorded size vs 50MB (can exceed while recording)">
            <div id="recBarFill"></div>
          </div>

          <div class="actions">
            <button id="startBtn" class="btn primary" type="button" disabled>‚è∫Ô∏è Start</button>
            <button id="stopBtn" class="btn danger" type="button" disabled>‚èπÔ∏è Stop</button>
            <button id="resetBtn" class="btn" type="button" disabled>üßπ Reset</button>
          </div>

          <div class="note">
            For GorillaDesk, we try to output MP4. If MP4 isn‚Äôt supported on this device, you‚Äôll see a warning.
          </div>
        </div>

        <div id="uploadPanel" style="display:none; margin-top:12px">
          <label for="fileInput">Choose a video (MP4/MOV preferred)</label>
          <input id="fileInput" type="file" accept="video/*" />
          <div class="note">
            Upload a video and convert it to ‚â§ 50MB. Output will be MP4 if supported by your browser.
          </div>
        </div>

        <hr style="border:none;border-top:1px solid var(--border);margin:14px 0">

        <div class="status">
          <span class="pill">Output target: <span class="mono" id="outTargetLabel">MP4 preferred</span></span>
          <span class="pill">Chosen output: <span class="mono" id="outMimeLabel">‚Äî</span></span>
          <span class="pill">GorillaDesk compatible: <span class="mono" id="gdCompatLabel">‚Äî</span></span>
        </div>

        <div class="actions">
          <button id="convertBtn" class="btn primary" type="button" disabled>üß™ Convert to ‚â§ 50MB</button>
          <button id="cancelConvertBtn" class="btn" type="button" disabled>‚úã Cancel</button>
        </div>

        <div id="progressBox" class="progressBox">
          <div class="progressTop">
            <div>Progress: <span class="mono" id="progressText">‚Äî</span></div>
            <div>Attempt: <span class="mono" id="attemptText">‚Äî</span></div>
          </div>
          <div class="log mono" id="progressLog"></div>
        </div>

        <div id="resultArea" style="margin-top:12px">
          <div class="note">Your converted video will appear here with Save/Share.</div>
        </div>
      </div>
    </section>

    <!-- hidden helper elements -->
    <div class="hiddenTools">
      <canvas id="xCanvas"></canvas>
      <video id="xVideo" playsinline muted></video>
    </div>
  </main>

  <!-- Settings Sheet -->
  <div id="sheetOverlay" class="sheetOverlay"></div>
  <div id="sheet" class="sheet" aria-hidden="true">
    <div class="sheetHeader">
      <h3>Settings</h3>
      <button id="closeSheetBtn" class="btn" type="button">‚úñÔ∏è Close</button>
    </div>
    <div class="sheetBody">
      <div class="twoCol">
        <div>
          <label for="cameraSelect">Camera</label>
          <select id="cameraSelect"></select>
        </div>
        <div>
          <label for="fpsSelect">FPS (record & convert)</label>
          <select id="fpsSelect">
            <option value="30">30</option>
            <option value="24">24</option>
            <option value="20">20</option>
            <option value="15" selected>15</option>
          </select>
        </div>
      </div>

      <div class="twoCol">
        <div>
          <label for="previewResSelect">Preview Resolution (camera)</label>
          <select id="previewResSelect">
            <option value="1280x720">720p (1280√ó720)</option>
            <option value="854x480" selected>480p (854√ó480)</option>
            <option value="640x360">360p (640√ó360)</option>
          </select>
        </div>
        <div>
          <label for="convertResSelect">Convert Max Resolution</label>
          <select id="convertResSelect">
            <option value="1280x720">720p max</option>
            <option value="854x480" selected>480p max</option>
            <option value="640x360">360p max</option>
            <option value="426x240">240p max</option>
          </select>
        </div>
      </div>

      <div>
        <label for="recordBitrate">Recording bitrate (kbps): <span class="mono" id="recordBitrateLabel">1500</span></label>
        <input id="recordBitrate" type="range" min="250" max="8000" step="50" value="1500" />
        <div class="note">Affects raw recording size/quality. Final size is controlled during conversion.</div>
      </div>

      <div>
        <label for="minQualitySelect">Minimum quality floor (conversion)</label>
        <select id="minQualitySelect">
          <option value="640x360|250">Min 360p @ 250 kbps</option>
          <option value="426x240|180" selected>Min 240p @ 180 kbps</option>
          <option value="320x180|120">Min 180p @ 120 kbps</option>
        </select>
      </div>

      <div class="twoCol">
        <div>
          <label>Camera Controls</label>
          <button id="torchBtn" class="btn" type="button" disabled>üî¶ Torch: n/a</button>
          <div class="note">Torch only works on some phones (usually rear camera).</div>
        </div>
        <div>
          <label for="zoomRange">Zoom: <span class="mono" id="zoomValue">n/a</span></label>
          <input id="zoomRange" type="range" min="1" max="1" step="0.1" value="1" disabled />
          <div class="note">Zoom depends on camera capabilities.</div>
        </div>
      </div>

      <div class="note">
        MP4 output requires MP4 encoding support in your browser. iPhone Safari often supports it; many Android browsers don‚Äôt.
      </div>
    </div>
  </div>

<script>
  /********************************************************************
   * 50MB Video Recorder/Converter (MP4-first)
   * - No FFmpeg. Uses canvas re-encode via MediaRecorder.
   * - Output MP4 if MediaRecorder supports it, else fallback to WebM.
   ********************************************************************/

  const MAX_BYTES = 50 * 1024 * 1024;
  const SAFETY_BYTES = 512 * 1024;

  const $ = (id) => document.getElementById(id);

  // UI
  const limitLabel = $("limitLabel");
  const secureBanner = $("secureBanner");
  const formatBanner = $("formatBanner");

  const tabRecord = $("tabRecord");
  const tabUpload = $("tabUpload");
  const recordPanel = $("recordPanel");
  const uploadPanel = $("uploadPanel");

  const preview = $("preview");
  const fileInput = $("fileInput");

  const enableCameraBtn = $("enableCameraBtn");
  const restartPreviewBtn = $("restartPreviewBtn");

  const startBtn = $("startBtn");
  const stopBtn = $("stopBtn");
  const resetBtn = $("resetBtn");

  const convertBtn = $("convertBtn");
  const cancelConvertBtn = $("cancelConvertBtn");

  const recSizeLabel = $("recSizeLabel");
  const recTimeLabel = $("recTimeLabel");
  const recBarFill = $("recBarFill");

  const resultArea = $("resultArea");

  const progressBox = $("progressBox");
  const progressText = $("progressText");
  const attemptText = $("attemptText");
  const progressLog = $("progressLog");

  const outTargetLabel = $("outTargetLabel");
  const outMimeLabel = $("outMimeLabel");
  const gdCompatLabel = $("gdCompatLabel");

  // Settings
  const settingsBtn = $("settingsBtn");
  const themeBtn = $("themeBtn");

  const sheetOverlay = $("sheetOverlay");
  const sheet = $("sheet");
  const closeSheetBtn = $("closeSheetBtn");

  const cameraSelect = $("cameraSelect");
  const fpsSelect = $("fpsSelect");
  const previewResSelect = $("previewResSelect");
  const convertResSelect = $("convertResSelect");
  const recordBitrate = $("recordBitrate");
  const recordBitrateLabel = $("recordBitrateLabel");
  const minQualitySelect = $("minQualitySelect");

  const torchBtn = $("torchBtn");
  const zoomRange = $("zoomRange");
  const zoomValue = $("zoomValue");

  const torchLabel = $("torchLabel");
  const zoomLabel = $("zoomLabel");

  // Hidden transcode elements
  const xCanvas = $("xCanvas");
  const xVideo = $("xVideo");

  // Theme
  const THEME_KEY = "vd_theme";
  function applyTheme(theme){
    document.documentElement.setAttribute("data-theme", theme);
    localStorage.setItem(THEME_KEY, theme);
  }
  applyTheme(localStorage.getItem(THEME_KEY) || "dark");
  themeBtn.addEventListener("click", () => {
    const cur = document.documentElement.getAttribute("data-theme") || "dark";
    applyTheme(cur === "dark" ? "light" : "dark");
  });

  // State
  let mode = "record";
  let stream = null;
  let videoTrack = null;

  let mediaRecorder = null;
  let chunks = [];
  let recordedBytes = 0;
  let startTs = 0;
  let tickTimer = null;

  let torchOn = false;

  // Source blob for conversion
  let sourceBlob = null;
  let sourceLabel = "";

  // Cancel support
  let cancelRequested = false;

  // Output mime selection
  let preferredOutputMime = "";
  let chosenOutputMime = ""; // set during conversion/recording attempts

  // Helpers
  function fmtMB(bytes){ return (bytes / (1024 * 1024)).toFixed(1) + " MB"; }
  function fmtTime(sec){
    if (sec < 60) return sec + "s";
    const m = Math.floor(sec/60);
    const s = sec % 60;
    return `${m}m ${s}s`;
  }

  function isSecureEnoughForCamera(){
    return window.isSecureContext === true;
  }

  function safeIsTypeSupported(mime){
    try{
      return !!(window.MediaRecorder && MediaRecorder.isTypeSupported && MediaRecorder.isTypeSupported(mime));
    }catch(_){
      return false;
    }
  }

  function pickPreferredOutputMime(){
    // MP4 first (GorillaDesk compatible), then WebM fallback
    const mp4Candidates = [
      "video/mp4;codecs=avc1.42E01E,mp4a.40.2",
      "video/mp4;codecs=avc1.4D401E,mp4a.40.2",
      "video/mp4"
    ];
    for (const t of mp4Candidates){
      if (safeIsTypeSupported(t)) return t;
    }

    const webmCandidates = [
      "video/webm;codecs=vp8,opus",
      "video/webm;codecs=vp9,opus",
      "video/webm"
    ];
    for (const t of webmCandidates){
      if (safeIsTypeSupported(t)) return t;
    }

    return ""; // let browser decide (may still work)
  }

  function isGorillaDeskCompatibleMime(mime){
    const m = (mime || "").toLowerCase();
    // GorillaDesk accepts mp4/mov (user reported); we treat mp4 as "yes". mov isn't produced by MediaRecorder.
    return m.includes("video/mp4") || m.includes("video/quicktime");
  }

  function updateOutputBadges(){
    const out = preferredOutputMime || "(browser default)";
    outMimeLabel.textContent = out;

    const ok = isGorillaDeskCompatibleMime(out);
    gdCompatLabel.textContent = ok ? "YES" : "NO";
    gdCompatLabel.className = "mono " + (ok ? "ok" : "warn");

    // Show warning banner if we cannot do mp4
    const mp4Supported = safeIsTypeSupported("video/mp4") ||
                         safeIsTypeSupported("video/mp4;codecs=avc1.42E01E,mp4a.40.2") ||
                         safeIsTypeSupported("video/mp4;codecs=avc1.4D401E,mp4a.40.2");

    // If preferred is NOT mp4, warn (because GorillaDesk won't accept webm)
    formatBanner.style.display = mp4Supported ? "none" : "block";
  }

  function setMode(next){
    mode = next;
    if (mode === "record"){
      tabRecord.classList.add("active");
      tabUpload.classList.remove("active");
      tabRecord.setAttribute("aria-selected","true");
      tabUpload.setAttribute("aria-selected","false");
      recordPanel.style.display = "";
      uploadPanel.style.display = "none";
    } else {
      tabUpload.classList.add("active");
      tabRecord.classList.remove("active");
      tabUpload.setAttribute("aria-selected","true");
      tabRecord.setAttribute("aria-selected","false");
      uploadPanel.style.display = "";
      recordPanel.style.display = "none";
    }
    updateConvertButtonState();
  }

  function updateConvertButtonState(){
    convertBtn.disabled = !sourceBlob || (mediaRecorder && mediaRecorder.state !== "inactive") || cancelRequested;
  }

  function showProgress(show){
    progressBox.style.display = show ? "block" : "none";
    if (!show){
      progressText.textContent = "‚Äî";
      attemptText.textContent = "‚Äî";
      progressLog.textContent = "";
    }
  }

  function logProgress(line){
    progressLog.textContent = (progressLog.textContent + "\n" + line).trim();
    progressLog.scrollTop = progressLog.scrollHeight;
  }

  function updateRecUI(){
    recSizeLabel.textContent = fmtMB(recordedBytes);
    const secs = startTs ? Math.max(0, Math.floor((Date.now() - startTs) / 1000)) : 0;
    recTimeLabel.textContent = fmtTime(secs);

    const pct = Math.min(100, (recordedBytes / MAX_BYTES) * 100);
    recBarFill.style.width = pct.toFixed(1) + "%";

    torchLabel.textContent = torchBtn.disabled ? "n/a" : (torchOn ? "On" : "Off");
    zoomLabel.textContent = zoomRange.disabled ? "n/a" : (Number(zoomRange.value).toFixed(1) + "x");
  }

  function clearResult(){
    resultArea.innerHTML = `<div class="note">Your converted video will appear here with Save/Share.</div>`;
  }

  function guessExtensionForMime(mime){
    const m = (mime || "").toLowerCase();
    if (m.includes("video/mp4")) return "mp4";
    if (m.includes("quicktime")) return "mov";
    if (m.includes("video/webm")) return "webm";
    return "mp4"; // default to mp4 extension, but mime should guide real compatibility
  }

  function renderResult(blob, label){
    const url = URL.createObjectURL(blob);

    const ext = guessExtensionForMime(blob.type || preferredOutputMime || "");
    const ok = isGorillaDeskCompatibleMime(blob.type || preferredOutputMime || "");

    resultArea.innerHTML = `
      <div class="pill" style="width:100%; justify-content:space-between; margin-bottom:10px;">
        <span>${label || "Final"}: <span class="mono ${blob.size <= (MAX_BYTES - SAFETY_BYTES) ? "ok" : "warn"}">${fmtMB(blob.size)}</span></span>
        <span class="mono">${blob.type || "video/*"}</span>
      </div>

      <div class="pill" style="width:100%; justify-content:space-between; margin-bottom:10px;">
        <span>GorillaDesk compatible:</span>
        <span class="mono ${ok ? "ok" : "warn"}">${ok ? "YES" : "NO (WebM not accepted)"}</span>
      </div>

      <video controls playsinline style="width:100%; border-radius:14px; background:#000; margin-bottom:10px;">
        <source src="${url}" type="${blob.type || ""}">
      </video>

      <div class="actions">
        <a class="btn primary" href="${url}" download="gorilladesk-video.${ext}">‚¨áÔ∏è Save</a>
        <button class="btn" id="shareBtn" type="button">üì§ Share</button>
      </div>

      ${ok ? "" : `<div class="note warn">
        This output is WebM. GorillaDesk won‚Äôt accept it. Use iPhone Safari over HTTPS (so MP4 is available), or use a server converter.
      </div>`}
    `;

    const shareBtn = document.getElementById("shareBtn");
    shareBtn.addEventListener("click", async () => {
      try{
        const file = new File([blob], `gorilladesk-video.${ext}`, { type: blob.type || "video/*" });
        if (navigator.canShare && navigator.canShare({ files: [file] }) && navigator.share){
          await navigator.share({ files:[file], title:"Video", text:"Compressed video (‚â§ 50MB)" });
        } else {
          alert("Share is not supported here. Use Save instead.");
        }
      }catch(err){
        console.error(err);
        alert("Share failed on this device/browser. Use Save instead.");
      }
    });
  }

  // Settings sheet
  function openSheet(){
    sheetOverlay.style.display = "block";
    sheet.style.transform = "translateY(0)";
    sheet.setAttribute("aria-hidden","false");
  }
  function closeSheet(){
    sheetOverlay.style.display = "none";
    sheet.style.transform = "translateY(110%)";
    sheet.setAttribute("aria-hidden","true");
  }
  settingsBtn.addEventListener("click", openSheet);
  closeSheetBtn.addEventListener("click", closeSheet);
  sheetOverlay.addEventListener("click", closeSheet);

  // Camera controls
  function getCapsSafe(track){
    try{ return track?.getCapabilities ? track.getCapabilities() : {}; }catch(_){ return {}; }
  }

  async function applyTorch(on){
    if (!videoTrack) return;
    try{
      await videoTrack.applyConstraints({ advanced: [{ torch: !!on }] });
      torchOn = !!on;
      torchBtn.textContent = torchOn ? "üî¶ Torch: On" : "üî¶ Torch: Off";
      updateRecUI();
    }catch(e){
      console.error(e);
      alert("Torch failed on this device/camera.");
    }
  }

  async function applyZoom(z){
    if (!videoTrack) return;
    try{
      await videoTrack.applyConstraints({ advanced: [{ zoom: Number(z) }] });
      zoomValue.textContent = Number(z).toFixed(1) + "x";
      updateRecUI();
    }catch(e){}
  }

  function setupTorchZoomUI(){
    torchOn = false;
    torchBtn.disabled = true;
    torchBtn.textContent = "üî¶ Torch: n/a";

    zoomRange.disabled = true;
    zoomValue.textContent = "n/a";

    if (!videoTrack){
      updateRecUI();
      return;
    }

    const caps = getCapsSafe(videoTrack);

    if (caps.torch){
      torchBtn.disabled = false;
      torchBtn.textContent = "üî¶ Torch: Off";
    }

    if (caps.zoom && typeof caps.zoom.min === "number" && typeof caps.zoom.max === "number"){
      zoomRange.disabled = false;
      zoomRange.min = caps.zoom.min;
      zoomRange.max = caps.zoom.max;
      zoomRange.step = caps.zoom.step || 0.1;

      const settings = (videoTrack.getSettings && videoTrack.getSettings()) || {};
      const z = typeof settings.zoom === "number" ? settings.zoom : caps.zoom.min;
      zoomRange.value = z;
      zoomValue.textContent = Number(z).toFixed(1) + "x";
    }

    updateRecUI();
  }

  torchBtn.addEventListener("click", () => applyTorch(!torchOn));
  zoomRange.addEventListener("input", (e) => applyZoom(e.target.value));

  // Camera setup
  function stopStream(){
    if (!stream) return;
    stream.getTracks().forEach(t => t.stop());
    stream = null;
    videoTrack = null;
  }

  async function getDevices(){
    const devices = await navigator.mediaDevices.enumerateDevices();
    return devices.filter(d => d.kind === "videoinput");
  }

  async function populateCameras(){
    cameraSelect.innerHTML = "";
    const cams = await getDevices();
    cams.forEach((cam, idx) => {
      const opt = document.createElement("option");
      opt.value = cam.deviceId;
      opt.textContent = cam.label || `Camera ${idx+1}`;
      cameraSelect.appendChild(opt);
    });
  }

  async function startPreview(){
    stopStream();
    torchOn = false;

    const [w,h] = previewResSelect.value.split("x").map(Number);
    const fps = Number(fpsSelect.value);
    const deviceId = cameraSelect.value || undefined;

    const constraints = {
      audio: true,
      video: {
        deviceId: deviceId ? { ideal: deviceId } : undefined,
        facingMode: deviceId ? undefined : { ideal: "environment" },
        width: { ideal: w },
        height: { ideal: h },
        frameRate: { ideal: fps }
      }
    };

    stream = await navigator.mediaDevices.getUserMedia(constraints);
    preview.srcObject = stream;
    try{ await preview.play(); }catch(_){}
    videoTrack = stream.getVideoTracks()[0] || null;
    setupTorchZoomUI();
  }

  cameraSelect.addEventListener("change", async () => {
    if (mediaRecorder && mediaRecorder.state !== "inactive") return;
    try{ await startPreview(); }catch(e){ console.error(e); }
  });
  previewResSelect.addEventListener("change", async () => {
    if (mediaRecorder && mediaRecorder.state !== "inactive") return;
    try{ await startPreview(); }catch(e){ console.error(e); }
  });
  fpsSelect.addEventListener("change", async () => {
    if (mediaRecorder && mediaRecorder.state !== "inactive") return;
    try{ await startPreview(); }catch(e){ console.error(e); }
  });

  recordBitrate.addEventListener("input", () => {
    recordBitrateLabel.textContent = recordBitrate.value;
  });

  // Recording
  function resetRecordingState(){
    chunks = [];
    recordedBytes = 0;
    startTs = 0;
    if (tickTimer) clearInterval(tickTimer);
    tickTimer = null;
    updateRecUI();
  }

  async function startRecording(){
    if (!stream){
      alert("Tap Enable Camera first.");
      return;
    }

    cancelRequested = false;
    cancelConvertBtn.disabled = true;

    resetRecordingState();
    clearResult();

    // MP4-first recording too
    const mimeType = preferredOutputMime || pickPreferredOutputMime();
    chosenOutputMime = mimeType || "";

    const options = {};
    if (mimeType) options.mimeType = mimeType;
    options.videoBitsPerSecond = Number(recordBitrate.value) * 1000;

    try{
      mediaRecorder = new MediaRecorder(stream, options);
    }catch(e){
      console.error(e);
      alert("Recording failed to start on this browser/device.");
      return;
    }

    const TIMESLICE_MS = 1000;

    mediaRecorder.ondataavailable = (ev) => {
      if (!ev.data || ev.data.size === 0) return;
      chunks.push(ev.data);
      recordedBytes += ev.data.size;
      updateRecUI();
    };

    mediaRecorder.onstop = () => {
      startBtn.disabled = false;
      stopBtn.disabled = true;
      resetBtn.disabled = false;

      if (tickTimer) clearInterval(tickTimer);
      tickTimer = null;

      const type = mediaRecorder.mimeType || mimeType || "video/webm";
      const blob = new Blob(chunks, { type });

      sourceBlob = blob;
      sourceLabel = "Recorded";
      updateConvertButtonState();

      renderResult(blob, "Raw (recorded)");
    };

    mediaRecorder.start(TIMESLICE_MS);
    startTs = Date.now();

    startBtn.disabled = true;
    stopBtn.disabled = false;
    resetBtn.disabled = true;

    tickTimer = setInterval(updateRecUI, 400);
    updateRecUI();
  }

  function stopRecording(){
    if (!mediaRecorder) return;
    try{
      if (mediaRecorder.state !== "inactive") mediaRecorder.stop();
    }catch(e){ console.error(e); }
  }

  // Upload
  fileInput.addEventListener("change", async () => {
    const f = fileInput.files && fileInput.files[0];
    if (!f){
      sourceBlob = null;
      updateConvertButtonState();
      return;
    }
    sourceBlob = f;
    sourceLabel = "Uploaded";
    cancelRequested = false;
    cancelConvertBtn.disabled = true;

    updateConvertButtonState();
    clearResult();
    renderResult(f, "Raw (uploaded)");
  });

  // Tabs
  tabRecord.addEventListener("click", () => setMode("record"));
  tabUpload.addEventListener("click", () => setMode("upload"));

  // Buttons
  startBtn.addEventListener("click", startRecording);
  stopBtn.addEventListener("click", stopRecording);

  resetBtn.addEventListener("click", () => {
    resetRecordingState();
    clearResult();
    sourceBlob = null;
    sourceLabel = "";
    updateConvertButtonState();
    resetBtn.disabled = true;
  });

  // Enable preview buttons
  const enableCameraBtn = $("enableCameraBtn");
  const restartPreviewBtn = $("restartPreviewBtn");

  enableCameraBtn.addEventListener("click", async () => {
    try{
      if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia){
        alert("This browser does not support camera access.");
        return;
      }
      if (!isSecureEnoughForCamera()){
        alert("On iPhone, camera requires HTTPS. Hosting this page on HTTPS is the best fix.");
      }

      await startPreview();
      await populateCameras();

      if (!cameraSelect.value && cameraSelect.options[0]){
        cameraSelect.value = cameraSelect.options[0].value;
      }
      await startPreview();

      restartPreviewBtn.disabled = false;
      startBtn.disabled = false;

    }catch(e){
      console.error(e);
      alert("Could not start camera. If you opened from Files on iPhone, host it on HTTPS.");
    }
  });

  restartPreviewBtn.addEventListener("click", async () => {
    try{ await startPreview(); }
    catch(e){ console.error(e); alert("Preview restart failed."); }
  });

  // Conversion (canvas re-encode)
  async function getVideoMeta(blob){
    return new Promise((resolve) => {
      const url = URL.createObjectURL(blob);
      const v = document.createElement("video");
      v.preload = "metadata";
      v.muted = true;
      v.playsInline = true;
      v.onloadedmetadata = () => {
        const meta = { duration: Number.isFinite(v.duration) ? v.duration : 0, width: v.videoWidth||0, height: v.videoHeight||0 };
        URL.revokeObjectURL(url);
        resolve(meta);
      };
      v.onerror = () => {
        URL.revokeObjectURL(url);
        resolve({ duration: 0, width: 0, height: 0 });
      };
      v.src = url;
    });
  }

  function parseWH(str){
    const [w,h] = str.split("x").map(Number);
    return { w, h };
  }

  function computeBitratesForTarget(durationSec, targetBytes){
    const audioBps = 64_000;
    const totalBps = Math.max(120_000, Math.floor((targetBytes * 8) / Math.max(1, durationSec)));
    const videoBps = Math.max(80_000, totalBps - audioBps);
    return { videoBps, audioBps };
  }

  function scaleDownTier(curW, curH){
    const tiers = [
      { w: 1280, h: 720 },
      { w: 854,  h: 480 },
      { w: 640,  h: 360 },
      { w: 426,  h: 240 },
      { w: 320,  h: 180 }
    ];
    const area = curW * curH;
    const sorted = tiers.slice().sort((a,b)=> (b.w*b.h)-(a.w*a.h));
    const idx = sorted.findIndex(t => t.w === curW && t.h === curH);
    if (idx >= 0 && idx < sorted.length - 1) return sorted[idx + 1];
    return sorted.find(t => (t.w*t.h) < area) || sorted[sorted.length - 1];
  }

  function pickRecorderMimeForConversion(){
    // Prefer MP4; fallback WebM.
    const best = pickPreferredOutputMime();
    return best || "";
  }

  async function transcodeViaCanvas(inputBlob, outW, outH, fps, videoBps, audioBps){
    if (cancelRequested) throw new Error("cancelled");

    const inputUrl = URL.createObjectURL(inputBlob);
    xVideo.src = inputUrl;
    xVideo.muted = false;
    xVideo.playsInline = true;
    xVideo.preload = "auto";

    await new Promise((resolve, reject) => {
      xVideo.onloadedmetadata = () => resolve();
      xVideo.onerror = () => reject(new Error("Failed to load video for conversion"));
    });

    xCanvas.width = outW;
    xCanvas.height = outH;
    const ctx = xCanvas.getContext("2d", { alpha:false });

    const canvasStream = xCanvas.captureStream(fps);

    let mixedStream = canvasStream;
    try{
      const ac = new (window.AudioContext || window.webkitAudioContext)();
      const srcNode = ac.createMediaElementSource(xVideo);
      const dest = ac.createMediaStreamDestination();
      srcNode.connect(dest);
      srcNode.connect(ac.destination);
      const audioTrack = dest.stream.getAudioTracks()[0] || null;
      if (audioTrack){
        mixedStream = new MediaStream([...canvasStream.getVideoTracks(), audioTrack]);
      }
    }catch(_){
      // audio capture can fail; continue video-only
    }

    const outMime = pickRecorderMimeForConversion();
    chosenOutputMime = outMime || "(browser default)";

    const options = {};
    if (outMime) options.mimeType = outMime;
    options.videoBitsPerSecond = Math.floor(videoBps);
    options.audioBitsPerSecond = Math.floor(audioBps);

    let recorder;
    try{
      recorder = new MediaRecorder(mixedStream, options);
    }catch(e){
      URL.revokeObjectURL(inputUrl);
      throw new Error("MediaRecorder cannot encode with these settings on this device/browser.");
    }

    const outChunks = [];
    recorder.ondataavailable = (ev) => { if (ev.data && ev.data.size > 0) outChunks.push(ev.data); };

    let rafId = 0;
    let lastFrameTs = 0;
    const frameInterval = 1000 / fps;

    function drawFrame(ts){
      if (cancelRequested){
        try{ recorder.stop(); }catch(_){}
        return;
      }
      if (!lastFrameTs || (ts - lastFrameTs) >= frameInterval){
        lastFrameTs = ts;

        const vw = xVideo.videoWidth || outW;
        const vh = xVideo.videoHeight || outH;

        const scale = Math.min(outW / vw, outH / vh);
        const dw = Math.floor(vw * scale);
        const dh = Math.floor(vh * scale);
        const dx = Math.floor((outW - dw) / 2);
        const dy = Math.floor((outH - dh) / 2);

        ctx.fillStyle = "#000";
        ctx.fillRect(0, 0, outW, outH);
        ctx.drawImage(xVideo, 0, 0, vw, vh, dx, dy, dw, dh);
      }
      rafId = requestAnimationFrame(drawFrame);
    }

    const donePromise = new Promise((resolve, reject) => {
      recorder.onstop = () => resolve();
      recorder.onerror = () => reject(new Error("Recorder error during conversion"));
    });

    recorder.start(1000);
    try{ await xVideo.play(); }catch(_){}
    rafId = requestAnimationFrame(drawFrame);

    await new Promise((resolve) => { xVideo.onended = () => resolve(); });

    cancelAnimationFrame(rafId);
    try{ recorder.stop(); }catch(_){}
    await donePromise;

    URL.revokeObjectURL(inputUrl);

    const outType = recorder.mimeType || outMime || "video/webm";
    return new Blob(outChunks, { type: outType });
  }

  async function compressIteratively(inputBlob){
    cancelRequested = false;
    cancelConvertBtn.disabled = false;
    convertBtn.disabled = true;

    showProgress(true);
    progressText.textContent = "‚Ä¶";
    attemptText.textContent = "‚Äî";
    progressLog.textContent = "";

    const targetBytes = MAX_BYTES - SAFETY_BYTES;

    const meta = await getVideoMeta(inputBlob);
    const durationSec = Math.max(1, Math.round(meta.duration || 1));

    logProgress(`${sourceLabel || "Source"} size: ${fmtMB(inputBlob.size)} | duration ~${durationSec}s | meta ${meta.width}x${meta.height}`);
    if (inputBlob.size <= targetBytes){
      logProgress(`Already under limit (‚â§ ${fmtMB(targetBytes)}).`);
      return inputBlob;
    }

    const maxRes = parseWH(convertResSelect.value);
    const [minResStr, minKbpsStr] = minQualitySelect.value.split("|");
    const minRes = parseWH(minResStr);
    const minVideoBps = Number(minKbpsStr) * 1000;

    const tiers = [
      { w: 1280, h: 720 },
      { w: 854,  h: 480 },
      { w: 640,  h: 360 },
      { w: 426,  h: 240 },
      { w: 320,  h: 180 }
    ];

    let outW = Math.min(maxRes.w, meta.width || maxRes.w);
    let outH = Math.min(maxRes.h, meta.height || maxRes.h);
    const startTier = tiers.find(t => t.w <= outW && t.h <= outH) || tiers[tiers.length - 1];
    outW = startTier.w; outH = startTier.h;

    const fps = Number(fpsSelect.value);

    let attempt = 0;
    const MAX_ATTEMPTS = 10;

    let { videoBps, audioBps } = computeBitratesForTarget(durationSec, targetBytes);
    videoBps = Math.min(videoBps, 2_000_000);

    while (attempt < MAX_ATTEMPTS){
      if (cancelRequested) throw new Error("cancelled");
      attempt++;
      attemptText.textContent = String(attempt);

      const vbpsK = Math.max(80, Math.floor(videoBps / 1000));
      logProgress(`\n--- Attempt ${attempt} ---`);
      logProgress(`Try ${outW}x${outH} @ ~${vbpsK} kbps video + ${Math.floor(audioBps/1000)} kbps audio`);

      let outBlob;
      try{
        outBlob = await transcodeViaCanvas(inputBlob, outW, outH, fps, videoBps, audioBps);
      }catch(e){
        logProgress(`Convert error: ${e.message || e}`);
        const next = scaleDownTier(outW, outH);
        outW = next.w; outH = next.h;
        ({ videoBps, audioBps } = computeBitratesForTarget(durationSec, targetBytes));
        videoBps = Math.max(minVideoBps, Math.min(videoBps, 1_200_000));
        continue;
      }

      // Update badges based on actual output mime
      preferredOutputMime = pickPreferredOutputMime();
      outMimeLabel.textContent = outBlob.type || preferredOutputMime || "unknown";
      const compat = isGorillaDeskCompatibleMime(outBlob.type || "");
      gdCompatLabel.textContent = compat ? "YES" : "NO";
      gdCompatLabel.className = "mono " + (compat ? "ok" : "warn");

      logProgress(`Output size: ${fmtMB(outBlob.size)} | mime: ${outBlob.type || "unknown"}`);

      if (outBlob.size <= targetBytes){
        logProgress(`‚úÖ Success under limit (‚â§ ${fmtMB(targetBytes)}).`);
        return outBlob;
      }

      if (videoBps > (minVideoBps * 1.15)){
        videoBps = Math.max(minVideoBps, Math.floor(videoBps * 0.72));
        logProgress(`Still too big ‚Üí lowering bitrate to ~${Math.floor(videoBps/1000)} kbps`);
      } else {
        const next = scaleDownTier(outW, outH);
        outW = next.w; outH = next.h;

        if (outW < minRes.w || outH < minRes.h){
          throw new Error("Reached minimum quality floor; cannot compress under 50MB for this duration.");
        }

        ({ videoBps, audioBps } = computeBitratesForTarget(durationSec, targetBytes));
        videoBps = Math.max(minVideoBps, Math.min(videoBps, 1_200_000));
        logProgress(`Bitrate floor reached ‚Üí downscaling to ${outW}x${outH}, reset bitrate ~${Math.floor(videoBps/1000)} kbps`);
      }
    }

    throw new Error("Max attempts reached; could not compress under 50MB on this device.");
  }

  convertBtn.addEventListener("click", async () => {
    if (!sourceBlob) return;

    cancelRequested = false;
    cancelConvertBtn.disabled = false;
    convertBtn.disabled = true;

    try{
      clearResult();
      showProgress(true);
      logProgress(`Starting conversion‚Ä¶ (target ‚â§ ${fmtMB(MAX_BYTES - SAFETY_BYTES)})`);

      const out = await compressIteratively(sourceBlob);

      showProgress(false);
      cancelConvertBtn.disabled = true;
      cancelRequested = false;

      renderResult(out, "Final (‚â§ 50MB)");

    }catch(e){
      showProgress(false);
      cancelConvertBtn.disabled = true;

      const msg = (e && e.message) ? e.message : String(e);
      alert(msg);
      logProgress(`‚ùå Failed: ${msg}`);
    }finally{
      cancelRequested = false;
      updateConvertButtonState();
    }
  });

  cancelConvertBtn.addEventListener("click", () => {
    cancelRequested = true;
    cancelConvertBtn.disabled = true;
    logProgress("Cancel requested‚Ä¶");
  });

  // Init
  async function init(){
    limitLabel.textContent = fmtMB(MAX_BYTES);
    recordBitrateLabel.textContent = recordBitrate.value;

    // Secure context banner
    if (!isSecureEnoughForCamera()){
      secureBanner.style.display = "block";
    }

    // Output mime detection
    preferredOutputMime = pickPreferredOutputMime();
    outTargetLabel.textContent = "MP4 preferred";
    outMimeLabel.textContent = preferredOutputMime || "(browser default)";
    gdCompatLabel.textContent = isGorillaDeskCompatibleMime(preferredOutputMime) ? "YES" : "NO";
    gdCompatLabel.className = "mono " + (isGorillaDeskCompatibleMime(preferredOutputMime) ? "ok" : "warn");

    updateOutputBadges();

    setMode("record");
    updateRecUI();
    clearResult();

    // iOS gesture requirement: don‚Äôt auto-start camera
    startBtn.disabled = true;
    restartPreviewBtn.disabled = true;
    stopBtn.disabled = true;
    resetBtn.disabled = true;
  }

  // Wire up remaining handlers
  tabRecord.addEventListener("click", () => setMode("record"));
  tabUpload.addEventListener("click", () => setMode("upload"));

  enableCameraBtn.addEventListener("click", async () => {
    try{
      if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia){
        alert("This browser does not support camera access.");
        return;
      }
      if (!isSecureEnoughForCamera()){
        alert("On iPhone, camera requires HTTPS. Hosting this page on HTTPS is the best fix.");
      }

      await startPreview();
      await populateCameras();

      if (!cameraSelect.value && cameraSelect.options[0]){
        cameraSelect.value = cameraSelect.options[0].value;
      }
      await startPreview();

      restartPreviewBtn.disabled = false;
      startBtn.disabled = false;

    }catch(e){
      console.error(e);
      alert("Could not start camera. If you opened from Files on iPhone, host it on HTTPS.");
    }
  });

  restartPreviewBtn.addEventListener("click", async () => {
    try{ await startPreview(); }
    catch(e){ console.error(e); alert("Preview restart failed."); }
  });

  startBtn.addEventListener("click", startRecording);
  stopBtn.addEventListener("click", stopRecording);

  resetBtn.addEventListener("click", () => {
    resetRecordingState();
    clearResult();
    sourceBlob = null;
    sourceLabel = "";
    updateConvertButtonState();
    resetBtn.disabled = true;
  });

  // Settings sheet
  settingsBtn.addEventListener("click", () => {
    sheetOverlay.style.display = "block";
    sheet.style.transform = "translateY(0)";
    sheet.setAttribute("aria-hidden","false");
  });
  closeSheetBtn.addEventListener("click", () => {
    sheetOverlay.style.display = "none";
    sheet.style.transform = "translateY(110%)";
    sheet.setAttribute("aria-hidden","true");
  });
  sheetOverlay.addEventListener("click", () => {
    sheetOverlay.style.display = "none";
    sheet.style.transform = "translateY(110%)";
    sheet.setAttribute("aria-hidden","true");
  });

  // Update output support when settings change (some browsers differ by context)
  function refreshOutputSupport(){
    preferredOutputMime = pickPreferredOutputMime();
    outMimeLabel.textContent = preferredOutputMime || "(browser default)";
    const compat = isGorillaDeskCompatibleMime(preferredOutputMime);
    gdCompatLabel.textContent = compat ? "YES" : "NO";
    gdCompatLabel.className = "mono " + (compat ? "ok" : "warn");
    updateOutputBadges();
  }

  recordBitrate.addEventListener("input", () => { recordBitrateLabel.textContent = recordBitrate.value; });
  fpsSelect.addEventListener("change", refreshOutputSupport);
  previewResSelect.addEventListener("change", refreshOutputSupport);
  convertResSelect.addEventListener("change", refreshOutputSupport);

  init();
</script>
</body>
  </html>
